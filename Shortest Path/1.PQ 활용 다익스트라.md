### 문제: PQ 활용 다익스트라

```C++
#include <algorithm>
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

vector<pair<int, int>> GRAPH[100001];
vector<int> DIST(100001);

void dijkstra(int startNode)
{
    priority_queue<pair<int, int>> PQ;
    PQ.push({0, startNode});
    DIST[startNode] = 0;

    while (!PQ.empty())
    {
        int curDist = -PQ.top().first;
        int curNode = PQ.top().second;
        PQ.pop();

        if (DIST[curNode] < curDist)
            continue;

        for (int i = 0; i < GRAPH[curNode].size(); i++)
        {
            int nextNode = GRAPH[curNode][i].first;
            int nextDist = GRAPH[curNode][i].second;
            int newCost = curDist + nextDist;

            if (newCost < DIST[nextNode])
            {
                DIST[nextNode] = newCost;
                PQ.push({-newCost, nextNode});
            }
        }
    }
}

int main(void)
{
    int N, M, startNode;
    cin >> N >> M >> startNode;

    int from, to, cost;
    for (int i = 0; i < M; i++)
    {
        cin >> from >> to >> cost;
        GRAPH[from].push_back({to, cost});
    }

    fill(DIST.begin(), DIST.begin() + N + 1, 1e9);
    dijkstra(startNode);
    
    for (int i = 1; i <= N; i++)
    {
        if (DIST[i] != 1e9)
            cout << DIST[i] << '\n';
        else
            cout << "No Path\n";
    }

    return 0;
}
```

* 오름차순 정열을 통해, 공포도를 1부터 차례대로 계산 가능
